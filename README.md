# Distrinted_Computing_Practicals
The concept of Computational Intelligence builds on many existing technologies such as artificial intelligence, machine learning, data mining and optimisation algorithms. 

Title: Distributed Application using RPC for Remote ComputationProblem Statement: Design a distributed application using RPC for remote computation where client submits an integer value to the server and server calculates factorial and returns the result to the client program.
Theory:Remote Procedure Call (RPC) is a powerful mechanism for enabling communication between processes or programs across a network. It allows a client program to execute procedures or functions on a remote server as if they were local, abstracting away the complexities of network communication.
RPC Components:• Client: The program that initiates the RPC call.• 
Server: The program that executes the requested procedure.• Stub: A client-side proxy for the remote procedure, responsible for marshalling parameters and sending requests over the network.• Skeleton: A server-side proxy for the remote procedure, responsible for unmarshalling parameters and invoking the actual procedure.RPC Workflow:• The client invokes a procedure on the stub, passing parameters.• The stub marshals the parameters into a message and sends it over the network to the server.• The server's skeleton receives the message, unmarshals the parameters, and invokes the corresponding procedure.• The procedure executes on the server, producing a result.• The result is marshalled into a response message and sent back to the client.• The client's stub receives the response, unmarshals the result, and returns it to the client program.Procedure:Designing the RPC Interface:• Define the interface between the client and server. This includes specifying the method(s) that the client can call on the server.• For this application, define a method calculate_factorial(n) that takes an integer n as input and returns the factorial of n.Implementing the Server:• Set up a server program that listens for incoming RPC requests from clients.• Implement the calculate_factorial(n) method on the server. Use an appropriate algorithm (e.g., recursive or iterative) to calculate the factorial of n.• Expose the method to clients by registering it with the RPC framework.Implementing the Client:• Create a client program that sends an RPC request to the server.• Call the calculate_factorial(n) method on the server, passing the desired integer n as an argument.• Receive and process the result returned by the server.Testing:• Test the client-server interaction with various input values to ensure correctness and robustness.• Handle potential error cases gracefully, such as invalid input or server unavailability.Conclusion:Thus, we have successfully implemented a distributed application using RPC for remote computation. 

Title: Fuzzy set Operations & RelationsProblem Statement: Implement Union, Intersection, Complement and Difference operations on fuzzy sets. Also create fuzzy relations by Cartesian product of any two fuzzy sets and perform max-min composition on any two fuzzy relations.Theory:Fuzzy Set Operations1. Define Fuzzy Sets:o Choose a universe of discourse (U) representing the range of possible values for your variable.o Define two fuzzy sets, A and B, on the universe U using membership functions. Membership functions map elements in U to a degree of membership between 0 and 1. Common functions include triangular, trapezoidal, and Gaussian functions.2. Union (OR):o Implement a function that takes two fuzzy sets (A, B) and their membership functions (μ_A, μ_B) as input.o For each element x in U, calculate the degree of membership in the union (μ_A U B)(x) using the maximum of individual memberships:o μ_A U B(x) = max(μ_A(x), μ_B(x))3. Intersection (AND):o Implement a function that takes two fuzzy sets (A, B) and their membership functions (μ_A, μ_B) as input.o For each element x in U, calculate the degree of membership in the intersection (μ_A ∩ B)(x) using the minimum of individual memberships:o μ_A ∩ B(x) = min(μ_A(x), μ_B(x))4. Complement (NOT):o Implement a function that takes a fuzzy set (A) and its membership function (μ_A) as input.o For each element x in U, calculate the degree of membership in the complement (μ_Aᶜ)(x) by inverting the membership of A:o μ_Aᶜ(x) = 1 - μ_A(x)5. Difference (A except B):o Implement a function that takes two fuzzy sets (A, B) and their membership functions (μ_A, μ_B) as input.o For each element x in U, calculate the degree of membership in the difference (μ_A \ B)(x) using the membership of A and the complement of B:o μ_A \ B(x) = max(μ_A(x), μ_Bᶜ(x))Fuzzy Relations1. Cartesian Product:o Define two fuzzy sets, A and B, on universes U and V respectively.o The Cartesian product of A and B creates a new fuzzy relation R on the universe U x V (cartesian product of U and V).o The membership function of R, μ_R((u, v)), represents the degree of relationship between element u in U and element v in V.o Implement a function that takes two fuzzy sets (A, B) and their membership functions (μ_A, μ_B) as input.o For each pair (u, v) in U x V, calculate the degree of membership in the relation using the minimum of individual memberships:o μ_R((u, v)) = min(μ_A(u), μ_B(v))2. Max-Min Composition:o Define two fuzzy relations, R and S, on universes (U x V) and (V x W) respectively.o Max-min composition combines these relations to create a new fuzzy relation T on universe U x W.o The membership function of T, μ_T((u, w)), represents the composed relationship between element u in U and element w in W, considering the relationship between u and all elements v in V.o Implement a function that takes two fuzzy relations (R, S) and their membership functions (μ_R, μ_S) as input.o For each pair (u, w) in U x W, iterate through all elements v in V and calculate the intermediate values:o z_uv = min(μ_R((u, v)), μ_S((v, w)))o Use the maximum of these intermediate values as the degree of membership in the composed relation:Conclusion:Thus, we have successfully implemented a program for Fussy set operations& its relations. 

Title: Load balancing algorithmsProblem Statement: Write code to simulate requests coming from clients and distribute them among the servers using the load balancing algorithms.Theory:Part 1: Simulating Client RequestsProcedure:1. Define Client Request:o Create a class or data structure to represent a client request.o Include attributes like request ID, arrival time, processing time (randomly generated), and any additional relevant data.2. Client Arrival Process:o Implement a function to generate client requests with random inter-arrival times. You can use libraries like random to generate random time intervals between requests.o Consider using a loop or a timer to simulate requests arriving at specific intervals or continuously over a period.3. Request Queue:o Implement a data structure (e.g., list) to store pending client requests waiting for server assignment.Part 2: Load Balancing AlgorithmsAlgorithms:• Round Robin:o Maintain a list of available servers.o For each new request, assign it to the next server in the list and move that server to the end of the list.o This ensures each server receives requests in a round-robin fashion.• Least Connections:o Maintain a counter for the number of active connections on each server.o Assign a new request to the server with the fewest active connections.o This distributes requests based on current workload.• Weighted Round Robin:o Assign weights to each server based on processing power, memory, or other relevant factors.o Modify the round-robin algorithm to select servers based on their weights. Servers with higher weights receive requests more frequently.Implementation:1. Server Management:o Define a class or data structure to represent a server.o Include attributes like server ID, processing capacity (optional), and a flag indicating if it's busy processing a request.2. Load Balancer Class:o Implement the chosen load balancing algorithm(s) within a load balancer class.o The class should have methods to:▪ Add a new request to the request queue.▪ Select a server based on the chosen algorithm.▪ Assign the request to the selected server and update its busy flag.▪ Optionally, track and report metrics like average waiting time, server utilization, etc.Part 3: Simulation LoopProcedure:1. Main Loop:o Implement a loop that iterates for a set duration or processes a specific number of requests.o In each iteration:▪ Generate a new client request using the function from Part 1.▪ Add the request to the queue in the load balancer.▪ Call the load balancer's method to select a server and assign the request.▪ Optionally, update statistics and counters for monitoring performance.2. Output:o Print or store relevant data after the simulation, such as:▪ Total number of requests processed.▪ Average waiting time for requests.▪ Server utilization (percentage of time servers were busy).▪ Comparison of results across different load balancing algorithms (if applicable).Conclusion:Thus, we have successfully implemented a program to simulate the request using Load Balancing Algorithm. 

Title: Optimization of genetic algorithm parameter.Problem Statement: Optimization of genetic algorithm parameter in hybrid genetic algorithm-neural network modelling: Application to spray drying of coconut milk.Software Requirement:Python 3.9 and Jupiter/PyCharm/Any Equivalent EditorInput:Data SetOutput:Spam and Not Spam Classification.Theory:Genetic Algorithm (GA):Genetic Algorithms are heuristic optimization algorithms inspired by the process of natural selection and genetics. They are widely used for solving optimization problems. In hybrid genetic algorithm-neural network modeling, a genetic algorithm is often used to optimize the weights and biases of a neural network.Parameters of Genetic Algorithm:• Population Size (pop_size): The number of individuals in the population.• Mutation Rate (mutation_rate): The probability that a gene (parameter) will be mutated during reproduction.• Crossover Rate (crossover_rate): The probability that two individuals will exchange genetic information during crossover.• Selection Method: The method used to select individuals for reproduction, such as tournament selection or roulette wheel selection.• Termination Criteria: The condition under which the genetic algorithm terminates, such as reaching a maximum number of generations or achieving a desired fitness level.Optimization:Optimizing genetic algorithm parameters involves finding the combination of parameter values that results in the best performance of the hybrid model. This often requires experimentation and fine-tuning of parameters to achieve optimal results.Implementation:Steps for Optimization:• Initialization: Initialize the genetic algorithm parameters with initial values.• Create Hybrid Model: Implement the hybrid genetic algorithm-neural network model.• Parameter Tuning: Experiment with different values of genetic algorithm parameters.• Evaluation: Evaluate the performance of the hybrid model for each set of parameter values.• Optimization: Select the parameter values that yield the best performance based on predefined criteria.• Validation: Validate the optimized parameters on a separate dataset to ensure generalization.Conclusion:Thus, we have successfully implemented a program for Optimization of genetic algorithm parameter. 

Title: Clonal selection algorithmProblem Statement: Implementation of Clonal selection algorithm using Python.Theory:Introduction:Briefly introduce the concept of CLONALG and its inspiration from the biological immune system's clonal selection process.Explain how CLONALG utilizes antibodies (candidate solutions) and affinity (fitness function) to iteratively improve solutions.Core Principles:• Antibody Representation: Define how you will represent candidate solutions in your implementation. This could be binary strings for binary optimization problems or real-valued vectors for continuous problems.• Affinity Function: Design a function that evaluates the fitness or quality of each candidate solution (antibody) relevant to your chosen optimization problem.CLONALG Phases:• Initialization: Generate a random population of antibodies (candidate solutions).• Selection: Select high-affinity antibodies (good solutions) for cloning based on their fitness function values.• Cloning: Create clones of selected antibodies. The number of clones can be proportional to the antibody's affinity.• Hypermutation: Introduce random mutations to the clones with a low mutation rate to promote diversity.• Evaluation: Evaluate the affinity of all antibodies (original population and clones) using the fitness function.• Selection and Replacement: Select the best antibodies (including original population and mutated clones) to form the next generation, replacing low-affinity ones.• Termination: Stop the process when a termination criterion is met (e.g., reaching a maximum number of iterations or achieving a desired fitness value).Conclusion:Thus, we have successfully implemented a program for Clonal selection algorithm. 

Title: Neural style transferProblem Statement: Create and Art with Neural style transfer on given image using deep learning.Theory:Introduction:Neural Style Transfer (NST):• Neural Style Transfer is a deep learning technique that combines the content of one image (content image) with the style of another image (style image) to create a new image (generated image). • It leverages convolutional neural networks (CNNs) to extract content and style features from the input images and optimize a generated image to minimize the content distance from the content image and the style distance from the style image simultaneously.Key Steps of NST:• Choose Content and Style Images: Select a content image (the image whose content you want to retain) and a style image (the image whose artistic style you want to apply).• Preprocess Images: Preprocess the content and style images to prepare them for feeding into a CNN.• Define Loss Functions: Define content loss and style loss functions to measure the difference between the features of the generated image, content image, and style image.• Optimization: Use gradient descent or other optimization techniques to update the generated image to minimize the combined content and style loss.• Generate Artistic Image: Generate the final artistic image by optimizing the generated image.Conclusion:Thus, we have successfully implemented a program for Neural style transfer.
